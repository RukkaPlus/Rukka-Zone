{% extends 'docs-layout.html' %}

{% block head %}
<link rel="icon" href="{{ url_for('static', filename='img/js.svg') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/web/style-js.css') }}">
<script src="{{ url_for('static', filename='js/web/script-js.js') }}"></script>
{% endblock %}

{% block title %}JavaScript{% endblock %}

{% block header %}
<div>
  <h1>JavaScript</h1>
  <p><b>JavaScript</b> es un <b>lenguaje Web multiparadigma y de tipado debil</b> que permite manejar el comportamiento de una <b>pagina Web</b>. Es uno de los lenguajes mas importantes de la actualidad, por lo que se lo conoce como <b>el competidor directo de Python</b></p>
</div>
<img src="{{ url_for('static', filename='img/js.svg') }}" alt="js">
{% endblock %}

{% block index %}
<li><a href="#syntax">Syntax</a></li>
<li><a href="#basics-0">Hello, world!</a></li>
<li><a href="#basics-1">Variables</a></li>
<li><a href="#basics-1-0">Diferencia entre <code>let</code> y <code>var</code></a></li>
<li><a href="#basics-2">Tipos de datos</a></li>
<li><a href="#basics-2-0">Tipos de datos neutros</a></li>
<li><a href="#basics-3">Constantes</a></li>
<li><a href="#basics-4">Operadores</a></li>
<li><a href="#basics-5">Funciones</a></li>
<li><a href="#basics-6">Control de flujo</a></li>
<li><a href="#basics-6-0">Bucles</a></li>
<li><a href="#basics-6-1">Condicionales y switches</a></li>
<li><a href="#basics-6-2">Manejo de excepciones</a></li>
<li><a href="#advanced-0">Generator functions</a></li>
<li><a href="#advanced-1">Arrow functions</a></li>
<li><a href="#advanced-2">Promises</a></li>
<li><a href="#advanced-3">Async functions</a></li>
<li><a href="#advanced-4">Regular expressions</a></li>
<li><a href="#advanced-4-0">Usando las expresiones regulares</a></li>
<li><a href="#advanced-4-1">Modificadores</a></li>
<li><a href="#advanced-4-2">Patrones</a></li>
<li><a href="#advanced-4-3">Cuantificadores</a></li>
<li><a href="#oop">Programacion Orientada a Objetos</a></li>
<li><a href="#oop-0">Clases</a></li>
<li><a href="#oop-0-0">Clases en JavaScript</a></li>
<li><a href="#oop-1">Objetos</a></li>
<li><a href="#oop-1-0">Objetos en JavaScript</a></li>
<li><a href="#oop-2">Abstraccion</a></li>
<li><a href="#oop-3">Encapsulacion</a></li>
<li><a href="#oop-3-0">Encapsulacion en JavaScript</a></li>
<li><a href="#oop-4">Herencia</a></li>
<li><a href="#oop-4-0">Herencia en JavaScript</a></li>
<li><a href="#oop-5">Polimorfismo</a></li>
<li><a href="#oop-5-0">Polimorfismo en JavaScript</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#json-0">Convirtiendo JSON en Objetos</a></li>
<li><a href="#json-1">Convirtiendo Objetos en JSON</a></li>
<li><a href="#json-2">Principales reglas de un archivo JSON</a></li>
{% endblock %}

{% block main %}
<section>
  <h2 id="syntax">Syntax</h2>
  <p>El syntax de <b>JavaScript</b> es <b>CLike</b>, por lo que...</p>
  <ul>
    <li>Cada expresion finaliza con <code>;</code></li>
    <li>Los comentarios se manejan con <code>//</code> o <code>/* ... */</code></li>
    <li>Un bloque de codigo comienza con <code>{</code> y termina con <code>}</code></li>
    <li>Soporta <b>Unicode</b></li>
    <li>Los nombres de las variables no pueden comenzar con numeros, ni pueden tener un keyword como nombre ni tener espacios entre sus nombres</li>
    <li>Las variables pueden usar <b>Camel Case</b> o <b>Snake Case</b></li>
  </ul>
  <pre><code class="language-js" id="input-0">let variable1 = 12;
let variable2 = 'RukkaPlus';

function toCube(num) {
  /* Esta funcion toma un numero y retorna
   * el cuadrado del mismo.
   */
  let result = num ** 3;
  return result;
}

// Uso de las variables previamente definidas
console.log(`Hello! I'm ${variable2}, and I have ${toCube(variable1)} grains of coffee`);</code></pre>
  <button class="w3-button" onclick="execute('input-0', 'output-0');">Ejecutar</button>
  <div class="output-cont" id="output-0"></div>
</section>
<section>
  <h2 id="basics-0">Hello, world!</h2>
  <p>Es el programa mas basico que se puede hacer en un lenguaje de programacion. Imprime o escribe la palabra "Hello, world!" en un medio</p>
  <pre><code class="language-js" id="input-1">// Imprime "Hello, world!" en consola
console.log('Hello, world!');

// Imprime "Hello, world!" en el DOM
// document.write('Hello, world!');

// Notifica un "Hello, world!" en el navegador
// alert('Hello, world!');</code></pre>
  <button class="w3-button" onclick="execute('input-1', 'output-1');">Ejecutar</button>
  <div class="output-cont" id="output-1"></div>
</section>
<section>
  <h2 id="basics-1">Variables</h2>
  <p>Es un espacio en memoria que almacena un dato y puede cambiar de valor durante el programa. En <b>JavaScript</b> puede ser declarado con los keywords <code>let</code> y <code>var</code>. Pero no puede ser redeclarado</p>
  <pre><code class="language-js" id="input-2">// [ Definiendo una variable con `let` ]
let variable1;      // &lt- Declarando
variable1 = 12;     // &lt- Inicializando
// let variable1 = 12; // &lt- Ambas cosas
console.log(variable1);

// [ Definiendo una variable con `var` ]
var variable2;      // &lt- Declarando
variable2 = 12;     // &lt- Inicializando
// var variable2 = 12; // &lt- Ambas cosas
console.log(variable2);

// let variable1; // &lt- ERROR
// var variable2; // &lt- OK ???</code></pre>
  <button class="w3-button" onclick="execute('input-2', 'output-2');">Ejecutar</button>
  <div class="output-cont" id="output-2"></div>
  <section>
    <h3 id="basics-1-0">Diferencia entre <code>let</code> y <code>var</code></h3>
    <p>La diferencia es que <code>let</code> tiene un menor scope que <code>var</code>. Usando <code>var</code>, la variable esta disponible para todos los bloques de codigo del programa</p>
    <pre><code class="language-js" id="input-3">var foo = "Foo";
let bar = "Bar";

console.log(foo); // Foo
console.log(bar); // Bar
{ // Inicio de bloque
  var moo = "Mooo";
  let baz = "Bazz";
  console.log(moo); // Mooo
  console.log(baz); // Bazz
} // Fin de bloque
console.log(moo); // Mooo
console.log(baz); // ReferenceError</code></pre>
    <button class="w3-button" onclick="execute('input-3', 'output-3');">Ejecutar</button>
    <div class="output-cont" id="output-3"></div>
  </section>
</section>
<section>
  <h2 id="basics-2">Tipos de datos</h2>
  <p>En <b>JavaScript</b> existen diferentes tipos de datos, y cada uno de ellos se comporta de diferentes formas. Existen los <b>String</b>, los <b>Number</b>, los <b>Boolean</b>, los <b>Array</b>, los <b>Object</b>, etc</p>
  <pre><code class="language-js">// [ String ]
"Hello, world!";
'Hello, world!';
`Hello, world!`;
// [ Number ]
12;
12.5;
// [ Boolean ]
true;
false;
// [ Array ]
[12, 20.8, 'foo'];
// [ Object ]
let object0 = { name: 'RukkaPlus', programming: 'JavaScript' };
let object1 = {
  name: 'RukkaPlus',
  programming: 'JavaScript'
};</code></pre>
  <section>
    <h3 id="basics-2-0">Tipos de datos neutros</h3>
    <p>Los datos neutros no son utilizados en expresiones convencionalmente. Estos son <code>undefined</code>, <code>null</code> y <code>NaN</code></p>
    <pre><code class="language-js">undefined; // Representa un valor no definido
  let variable; // &lt- undefined

  null; // Representa a un valor nulo
  variable = null; // &lt- null

  NaN; // Representa a un valor que no es un numero
  'String' * 80; // &lt- NaN</code></pre>
  </section>
</section>
<section>
  <h2 id="basics-3">Constantes</h2>
  <p>Una constante es un espacio en memoria que una vez declarada no cambia durante el programa. Puede ser definida con el keyword <code>const</code></p>
  <pre><code class="language-js" id="input-4">const MY_CONSTANT = 'No puedes cambiarme :P';
console.log('La constante tiene como valor : '
  + MY_CONSTANT);
// MY_CONSTANT = -90; // &lt- ERROR</code></pre>
  <button class="w3-button" onclick="execute('input-4', 'output-4');">Ejecutar</button>
  <div class="output-cont" id="output-4"></div>
  <div class="w3-panel note">
    <p><b>Nota</b>: Las constantes son usadas cuando es necesario definir un valor que no necesitemos que cambie de valor en nuestro programa</p>
  </div>
</section>
<section>
  <h2 id="basics-4">Operadores</h2>
  <p>Los operadores son aquellos signos que nos permite relacionar variables, constantes o expresiones</p>
  <pre><code class="language-js">let x = 5;
// [ Operadores aritmeticos ]
5 + 2;  // Suma
8 - 4;  // Resta
5 * 6;  // Multiplicacion
60 / 5; // Division
21 % 4; // Modulo (resto)
3 ** 8; // Exponenciacion
x++;    // Incremento
x--;    // Decremento

// [ Operadores relacionales ]
10 > 5;     // Mayor que...
11 &lt 5;     // Menor que...
40 == 40;   // Igual que...
50 != 50;   // Diferente a...
60 >= 50;   // Mayor o igual que...
30 &lt= 30;   // Menor o igual que...
1 === 1;    // Mismo valor y mismo tipo que...
4.0 !== 1;  // Diferente valor o diferente tipo que...
true ? 'String 1' // Operador
     : 'String 2' // ternario

// [ Operadores Logicos ]
true && true;  // AND
true || false; // OR
!false;        // NOT

// [ Operadores de origen ]
typeof('I am a String'); // Retorna su tipo de dato
12 instanceof Number;    // Retorna su clase padre

// [ Operadores de asignacion ]
x = 12;  // Asignacion standard
x += 5;  // Asignacion con adicion
x -= 5;  // Asignacion con resta
x *= 2;  // Asignacion con multiplicacion
x /= 3;  // Asignacion con division
x %= 3;  // Asignacion con modulo
x **= 5; // Asignacion con potenciacion

// [ Operadores binarios ]
5 & 1;   // AND (0101 & 0001 = 0001 = 5)
5 | 1;   // OR  (0101 | 0001 = 0101 = 5)
~5;      // NOT (~0101       = 1010 = 10)
5 ^ 1;   // XOR (0101 ^ 0001 = 0100 = 4)
5 &lt&lt 1;  // Zero fill left shift (0101 &lt&lt 1 = 1010 = 10)
5 >> 1;  // Signed fill right shift (0101 >> 1 = 0010 = 2)
5 >>> 1; // Zero fill right shift (0101 >>> 1 = 0010 = 2)</code></pre>
</section>
<section>
  <h2 id="basics-5">Funciones</h2>
  <p>Una funcion es un algoritmo definido que puede ser ejecutado durante el programa. Se definen usando el keyword <code>function</code></p>
  <pre><code class="language-js" id="input-5">// Para definir una funcion
function myFunction0() {
  console.log("Hello, World!");
}
// Para asignar una funcion en una variable
let myFunction1 = function(parm) {
  console.log(`Hello, ${parm}!`); 
}
// Para definir una funcion con parametros
function myFunction2(parm0, parm1) {
  return `${parm0} + ${parm1} = ${parm0 + parm1}`; // &lt- Retorna un valor
}

// Ejecutando funciones
myFunction0();
myFunction1("RukkaPlus");
console.log(myFunction2(5, 10));</code></pre>
  <button class="w3-button" onclick="execute('input-5', 'output-5');">Ejecutar</button>
  <div class="output-cont" id="output-5"></div>
</section>
<section>
  <h2 id="basics-6">Control de flujo</h2>
  <p>Son estructuras que nos permite controlar el flujo del programa. Pueden ser <b>bucles</b>, <b>condicionales y switches</b> y <b>manejadores de excepciones</b></p>
  <section>
    <h3 id="basics-6-0">Bucles</h3>
    <p>Son estructuras que repiten un algoritmo una determinada cantidad de veces. Existen tres estructuras de bucle: <code>while</code>, <code>do...while</code> y <code>for</code></p>
    <pre><code class="language-js" id="input-6">// [ for ]
// Repite un numero de veces
let i;
for (i = 0; i &lt 5; i++) {
  console.log('Estoy en el bucle FOR');
}

// [ while ]
// Repite siempre que se cumpla la condicion
while (i > 0) {
  console.log('Estoy en el bucle WHILE');
  i--;
}

// [ do...while ]
// Ejecuta al menos una vez y repite siempre que se
// cumpla la condicion
do {
  console.log('Estoy en el bucle DO...WHILE');
  i++;
} while (i &lt 5);

// [ for...in ]
// Itera un objeto pero solo usando la posicion como
// referencia
list = ['John', 'Charles', 'Maria'];
let element;
for (element in list) {
  console.log('Estoy dentro del bucle FOR...IN\n' +
  'Estoy apuntando al item: ' + element + ' de `list`');
}

// [ for...of ]
// Parecido al `For...in`, sin embargo, este extrae sus
// valores reales
for (element of list) {
  console.log('Estoy dentro del bucle FOR...OF\n' +
  'Estoy apuntando al item: ' + element + ' de `list`');
}

/* [ keywords ]
 * break : Rompe la ejecucion de un bloque.
 * continue : Repite el bloque de codigo.
 * label : Define un identificador para actuar sobre el.
 */
label1 :
for (i = 0; i &lt 15; i++) {
  console.log('Esto es una prueba...');
  if (i == 10) {
    break; // &lt- Rompe ejecucion
  } else if (i == 11) {
    continue; // &lt- Repite ejecucion
  }

  let name = 'George';
  while (name != 'John') {
    break label1;
  }
  console.log('Soy inalcanzable');
}</code></pre>
    <button class="w3-button" onclick="execute('input-6', 'output-6');">Ejecutar</button>
    <div class="output-cont" id="output-6"></div>
  </section>
  <section>
    <h3 id="basics-6-1">Condicionales y switches</h3>
    <p>Permite que el programa ejecute un algoritmo en base a una condicion o caso. Las dos estructuras que permiten dicha accion, son <code>if...else</code> y <code>switch</code></p>
    <pre><code class="language-js" id="input-7">// [ Condicionales ]
let variable = 'RukkaPlus';
if (variable == 'RukkaPlus') {
  // Si esta condicion se cumple...
  console.log('La primera condicion fue cumplida');
} else if (variable == 'Narumi') {
  // Si la condicion anterior no se cumple, pero
  // esta si, entonces...
  console.log('La segunda condicion fue cumplida');
} else {
  // Si ninguna anterior se cumple, entonces...
  console.log('Ninguna de las anteriores fue cumplida')
}

// [ Switch ]
switch (variable) {
  case 'Narumi': // Si este es el caso, entonces...
    console.log('Se cumplio el caso 1');
    break; // &lt- Esto interrumpe la ejecucion
  case 'RukkaPlus':  // Si este es el caso, entonces...
    console.log('Se cumplio el caso 2');
    break; // &lt- Esto interrumpe la ejecucion
  default: // Si no se cumplen las anteriores...
    console.log('Se cumplio el caso default');
    // break; // &lt- No requerido
}</code></pre>
    <button class="w3-button" onclick="execute('input-7', 'output-7');">Ejecutar</button>
    <div class="output-cont" id="output-7"></div>
  </section>
  <section>
    <h3 id="basics-6-2">Manejo de excepciones</h3>
    <p>El manejo de excepciones nos permite controlar el flujo del programa a partir de la causa una excepcion. Esto lo podemos manejar con las estructuras <code>try</code>, <code>catch</code>, <code>finally</code> y <code>throw</code></p>
    <pre><code class="language-js" id="input-8">// Estructuras
try {
  // Esta estructura es propensa a errores...
  throw 'ERROR GRAVISIMO!!!'; // Arroja un error
} catch(variableError) {
  // Si un error se produjo...
  console.error('Se ha producido un error');
} finally {
  // Haya ocurrido o no un error...
  console.log('Ha terminado la ejecucion');
}

/* [ Glosario ]
 * try : Define a una estructura propensa a errores.
 *     : Se ejecuta el algoritmo hasta que ocurra uno.
 * catch(err) : Maneja el error que se haya producido
 *            : en la estructura `try`.
 * finally : Define a una estructura que se ejecutara
 *         : si hubo o no un error.
 * throw : Arroja un error personalizado. Puede ser de
 *       : de tipo String, Numero, etc.
 */</code></pre>
    <button class="w3-button" onclick="execute('input-8', 'output-8');">Ejecutar</button>
    <div class="output-cont" id="output-8"></div>
  </section>
</section>
<section>
  <h2 id="advanced-0">Generator functions</h2>
  <p>Los <b>generator functions</b> son funciones que trabajan como <b>objetos iterables</b>. Se definen con <code>function*</code> en lugar de <code>function</code> y se coloca <code>yield someValue</code> en cada lugar lugar donde deba retornarse un valor. Para ir avanzando de <code>yield</code> en <code>yield</code>, se utiliza el metodo de <b>objetos iterables</b> <code>next()</code></p>
  <pre><code class="language-js" id="input-9">let num;
function* funcionGenerador() {
  console.log('Iniciando carga...');
  yield 20; /* Aqui se detiene la iteracion
             * Y retorna un valor
             */
  console.log('Cargando archivos...');
  yield 40;

  console.log('Carga completa!');
  yield 60;
}
let objetoGenerador = funcionGenerador();
num = objetoGenerador.next(); // &lt- {value: 20, done: false}
num = objetoGenerador.next(); // &lt- {value: 40, done: false}
num = objetoGenerador.next(); // &lt- {value: 60, done: true}</code></pre>
  <button class="w3-button" onclick="execute('input-9', 'output-9');">Ejecutar</button>
  <div class="output-cont" id="output-9"></div>
</section>
<section>
  <h2 id="advanced-1">Arrow functions</h2>
  <p>Un <b>Arrow function</b> es una manera reducida de declarar funciones en <b>JavaScript</b>. Fue introducida en <b>ES6</b> y se representa literalmente como una flecha (<code>=></code>)</p>
  <pre><code class="language-js" id="input-10">// Declaracion regular de una funcion
function multiplicar0(a, b) {
  return a * b;
}

// Declaracion usando arrow function
let multiplicar1 = (a, b) => a * b;

let result0 = multiplicar0(5, 2); // &lt- 10
let result1 = multiplicar1(5, 2); // &lt- 10
console.log(result0);
console.log(result1);</code></pre>
  <button class="w3-button" onclick="execute('input-10', 'output-10');">Ejecutar</button>
  <div class="output-cont" id="output-10"></div>
</section>
<section>
  <h2 id="advanced-2">Promises</h2>
  <p>Los <b>Promisees</b> vienen con la intencion de remover los <b>Callback hell</b>, que consisten en realizar varias funciones anidadas (donde al finalizar una funcion se llama a otra sucesivamente). <br> Un <code>Promise</code> (o promesa) representa el final (o fracaso) eventual de una operacion asincrona</p>
  <pre><code class="language-js">// [ Callback hell ]
const compras = [];
setTimeout(() => {
  compras.push('Verduras');
  console.log('He terminado de comprar verduras');
  setTimeout(() => {
    compras.push('Carne');
    console.log('He terminado de comprar carne');
    setTimeout(() => {
      compras.push('Granos');
      console.log('He terminado de comprar granos');
    }, 2000);
  }, 2000);
}, 2000);

// Notese la piramide del medio del codigo...</code></pre>
  <pre><code class="language-js" id="input-11">// [ Promises ]
const compras = [];
new Promise((res, rej) => {
  // Resolve indica el final exitoso de la promesa
  // Reject indica el error ocurrido en la promesa
  setTimeout(() => {
    compras.push('Verduras');
    console.log('He terminado de comprar verduras');
    res("Success!");
  }, 2000);
}).then(result => {
  // Si el Resolve es ejecutado con exito...
  new Promise((res, rej) => {
    setTimeout(() => {
      compras.push('Carne');
      console.log('He terminado de comprar carne');
      res("Success!");
    }, 2000);
  }).then(result => {
    // Si el Resolve es ejecutado con exito...
    new Promise((res, rej) => {
      setTimeout(() => {
        compras.push('Granos');
        console.log('He terminado de comprar granos');
        rej("Error!");
      }, 2000);
    }).catch(err => {
      // Si un Reject es activado...
      console.error('Ocurrio un error : ' + err);
    });
  });
});</code></pre>
  <button class="w3-button" onclick="execute('input-11', 'output-11');">Ejecutar</button>
  <div class="output-cont" id="output-11"></div>
</section>
<section>
  <h2 id="advanced-3">Async functions</h2>
  <p>Las <b>Async functions</b> son funciones que ejecutan procesos dentro de ellas de manera asincrona (esperando a que un proceso termine completamente antes de continuar). Esta es una actualizacion basado en promesas <br> Para definir una <b>Async function</b> debemos anteponer el keyword <code>async</code> a <code>function</code> en una declaracion</p>
  <pre><code class="language-js" id="input-12">const compras = [];
(async function funcionAsincrona() {
  await new Promise((res, rej) => {
    setTimeout(() => {
      compras.push('Verduras');
      console.log('He terminado de comprar verduras');
      res('Terminamos!');
    }, 2000);
  });
  await new Promise((res, rej) => {
    setTimeout(() => {
      compras.push('Carne');
      console.log('He terminado de comprar carne');
      res('Terminamos!');
    }, 2000);
  });
  await new Promise((res, rej) => {
    setTimeout(() => {
      compras.push('Granos');
      console.log('He terminado de comprar granos');
      res('Terminamos!');
    }, 2000);
  });
})()</code></pre>
  <button class="w3-button" onclick="execute('input-12', 'output-12');">Ejecutar</button>
  <div class="output-cont" id="output-12"></div>
</section>
<section>
  <h2 id="advanced-4">Regular expressions</h2>
  <p>Las expresiones regulares en <b>JavaScript</b> se representan en un tipo de dato que se conoce como <code>regExp</code> y se escriben con el syntax <code>/pattern/modifier</code></p>
  <pre><code class="language-js">// Ejemplo de regExp
let myRegExp = /JavaScript/i

/* 'JavaScript' es el patron usado en la busqueda
 * 'i' es un modificador que indica 'case insensitive'
 */</code></pre>
  <section>
    <h3 id="advanced-4-0">Usando las expresiones regulares</h3>
    <p>Se usan en metodos de busqueda. Mas especificamente en <code>search()</code> y <code>replace()</code> de los Strings</p>
    <pre><code class="language-js" id="input-13">// Ejemplo de regExp en 'search()'
let text0 = "This is a text writted in JAVASCRIPT language";
let result0 = text0.search(/javascript/i); // return 26

// Ejemplo de regExp en 'replace()'
let text1 = "In this text, 'cookie' will be replaced by 'replaceme'";
let result1 = text1.replace(/REPLACEME/i, 'milk'); // return String

console.log(`La posicion de "JAVASCRIPT" en "text0" es : ${result0}`);
console.log(`La palabra "cookie" en "text1" fue reemplazada por "milk" : ${result1}`);</code></pre>
    <button class="w3-button" onclick="execute('input-13', 'output-13');">Ejecutar</button>
    <div class="output-cont" id="output-13"></div>
  </section>
  <section>
    <h3 id="advanced-4-1">Modificadores</h3>
    <ul>
      <li><code>i</code> : Perform case-insensitive matching</li>
      <li><code>g</code> : Perform a global match (find all matches rather than stopping after the first match)</li>
      <li><code>m</code> : Perform multiline matching</li>
    </ul>
  </section>
  <section>
    <h3 id="advanced-4-2">Patrones</h3>
    <ul>
      <li><code>[abc]</code> : Find any of the characters between the brackets</li>
      <li><code>[0-9]</code> : Find any of the digits between the brackets</li>
      <li><code>(x|y)</code> : Find any of the alternatives separated with '|'</li>
      <li><code>\d</code> : Find a digit</li>
      <li><code>\s</code> : Find a whitespace character</li>
      <li><code>\b</code> : Find a match at the beginning of a word like this: \bWORD, or at the end of a word like this: WORD\b</li>
      <li><code>\uxxxx</code> : Find the Unicode character specified by the hexadecimal number xxxx</li>
    </ul>
  </section>
  <section>
    <h3 id="advanced-4-3">Cuantificadores</h3>
    <ul>
      <li><code>n+</code> : Matches any string that contains at least one n</li>
      <li><code>n*</code> : Matches any string that contains zero or more occurrences of n</li>
      <li><code>n?</code> : Matches any string that contains zero or one occurrences of n</li>
    </ul>
  </section>
</section>
<section>
  <h2 id="oop">Programacion Orientada a Objetos</h2>
  <p>La programacion orientada a objetos es un paradigma de la programacion que nos permite manejar y estructurar de una manera mas ordenada y compacta un programa <br> <b>JavaScript</b> es un lenguaje completamente orinetado a objetos, por lo que entenderlo es importante para conocer otros aspectos del lenguaje <br> Para suerte de todo programador, la programacion orientada a objetos en <b>JavaScript</b> es muy sencilla de entender</p>
  <section>
    <h3 id="oop-0">Clases</h3>
    <p>Una clase es una abstraccion que hacemos para nuestra experiencia sensible. El ser humano tiende a agrupar cosas (objetos) con caracteristicas similares en grupos (clases). Por ejemplo: Un vaso pequenio o un vaso grande, ambos son de la clase "Vaso"</p>
    <section>
      <h4 id="oop-0-0">Clases en JavaScript</h4>
      <p>Para definir una clase, es necesario anteponer el keyword <code>class</code> al nombre de la clase <br> El metodo constructor es necesario para definir la construccion del objeto. Al momento de instanciar la clase, se ejecutara este metodo constructor</p>
      <pre><code class="language-js">class Persona {
  // Metodo constructor
  constructor(nombre, edad) {
    this.nombre = nombre;
    this.edad = edad;
  }
  // Metodo standard
  caminar() {
    console.log(this.nombre + ' esta caminando');
  }
  // Metodos getter/setter
  get attrNombre() {
    return this.nombre;
  }
  set attrEdad(x) {
    this.edad = x;
  }
}</code></pre>
    </section>
  </section>
  <section>
    <h3 id="oop-1">Objetos</h3>
    <p>Es un conjunto de atributos y metodos. Un objeto se deriva de una clase. Por ejemplo: Un vaso pequenio es un objeto de la clase "Vaso"</p>
    <ul>
      <li>El vaso pequenio tiene como atributo: Es pequenio.</li>
      <li>El vaso pequenio tiene como metodo: Servir agua en el.</li>
    </ul>
    <section>
      <h4 id="oop-1-0">Objetos en JavaScript</h4>
      <p>En <b>JavaScript</b> <b>casi todo es un objeto</b>. Desde los <b>tipos de datos primitivos</b> (String, Number, Boolean, BigInt, undefined, Symbol, null) hasta los <b>tipos de datos no-primitivos</b> (Array, Object, etc) <br> Para instanciar una clase previamente definida, se antepone el keyword <code>new</code> a la clase de la que se realizara una instancia</p>
      <pre><code class="language-js">// Instanciando una clase
let personaStd = new Persona('RukkaPlus', 16);

// Accediendo a metodos
personaStd.caminar();

// Accediendo a un getter
let personaStdNombre = personaStd.objNombre; // &lt- RukkaPlus
personaStd.objEdad(18);                      // -&gt 18</code></pre>
      <p>Como se puede apreciar, para realizar una instancia es necesario escribir <code>new NombreDeClase(1, 2, 3);</code>, donde <code>new</code> indica que se realizara una instancia, y <code>NombreDeClase(1, 2, 3);</code> es el nombre de la clase y la llamada a su metodo constructor</p>
    </section>
  </section>
  <section>
    <h3 id="oop-2">Abstraccion</h3>
    <p>Es un proceso mental de extraccion de las caracteristicas esenciales de algo, ignorando los detalles superfluos. Por ejemplo: El vaso pequenio tiene como detalles que... Es pequenia; Podemos servir agua en ella; Es redonda; Es de vidrio; etc. Por que habria de poner algo como... El numero atomico que tiene? (a no ser que nuestro programa lo requiera)</p>
  </section>
  <section>
    <h3 id="oop-3">Encapsulacion</h3>
    <p>Es un proceso por el cual se ocultan los detalles del soporte de las caracteristicas de una abstraccion. Por ejemplo: Cuando te sirves agua en el vaso pequenio y la bebes, solo la estas utilizando. No necesitas saber de que metodos o atributos tendrian (por ejemplo) el vidrio con el que esta hecho, solo necesitas saber que te sirvio para beber agua. Encapsulas ese objeto para que no te metas con los datos</p>
    <section>
      <h4 id="oop-3-0">Encapsulacion en JavaScript</h4>
      <p>En <b>JavaScript</b> tenemos tres categorias de atributos y metodos: <b>Public</b> (el atributo/metodo esta disponible en todo el programa y pueden ser heredadas), <b>Protected</b> (el atributo/metodo esta disponible dentro de las instancias y pueden ser heredadas) y <b>Private</b> (el atributo/metodo esta disponible unicamente dentro de las instacias y no pueden ser heredadas)</p>
      <pre><code class="language-js">/* [ Definicion de atributos/metodos ]
 * Los atributos/metodos publicos son definidos normalmente
 * Los atributos/metodos protegidos son definidos con "_" al inicio
 * Los atributos/metodos privados son definidos con "#" al inicio
 */
class MyClass {
  myPublicAttr     = "Hello, world!";
  _myProtectedAttr = "Hello, world!";
  #myPrivateAttr   = "Hello, world!";
  get getAttr() {
    return {
      publicAttr: this.myPublicAttr,        // "Hello, world!"
      protectedAttr: this._myProtectedAttr, // "Hello, world!"
      privateAttr: this.#myPrivateAttr      // "Hello, world!"
    }
  }
}
class MySubClass extends MyClass {
  getAttr() {
    return {
      publicAttr: this.myPublicAttr,        // "Hello, world!"
      protectedAttr: this._myProtectedAttr  // "Hello, world!"
      // privateAttr: this.#myPrivateAttr   // ERROR
    }
  }
}
let instance = new MyClass();
instance.myPublicAttr;        // "Hello, world!"
// instance._myProtectedAttr; // ERROR
// instance.#myPrivateAttr;   // ERROR</code></pre>
    </section>
  </section>
  <section>
    <h3 id="oop-4">Herencia</h3>
    <p>La herencia es donde una clase nueva se crea a partir de una clase ya existente, heredando todos sus atributos y metodos. Por ejemplo: De la clase "Vaso" (superclase) se pudo haber sacado otra clase heredada llamada "Vaso pequenio" (subclase). Asi se heredan sus atributos y metodos variando solo algunas caracteristicas como por ejemplo, su tamanio</p>
    <section>
      <h4 id="oop-4-0">Herencia en JavaScript</h4>
      <p>Como se ha mencionado anteriormente, la herencia es <b>la accion de heredar de una clase ya existente</b>, heredando los atributos y metodos de la <b>superclase</b> a la <b>subclase</b>. (tambien llamados <b>clase padre</b> y <b>clase hijo</b> respectivamente) <br> Para realizar una herencia en <b>JavaScript</b>, en la linea de declaracion de la subclase, se usa el keyword <code>extends</code> seguido del nombre de la superclase.</p>
      <pre><code class="language-js">class Programador extends Persona {
  // Metodo constructor
  constructor(nombre, edad, lenguaje) {
    super(nombre, edad);
    this.lenguaje = lenguaje;
  }
  // Metodo standard
  programar() {
    console.log(this.nombre + ' esta programando con '
      + this.lenguaje);
  }
}
// Instanciacion
let programadorStd = new Programador('RukkaPlus', 15, 'JavaScript');
programadorStd.programar(); // Metodo nuevo
let programadorStdNombre = programadorStd.objNombre; // Metodo heredado</code></pre>
    </section>
  </section>
  <section>
    <h3 id="oop-5">Polimorfismo</h3>
    <p>Es aquella cualidad que poseen los objetos para responder de distinto modo ante el mismo mensaje. Por ejemplo: Si servimos agua en un vaso pequenio y en un vaso grande, ambos responderan de distinta forma ante el mismo metodo (por ejemplo, en el vaso pequenio entrara menos agua y en el vaso grande entrara mas)</p>
    <section>
      <h4 id="oop-5-0">Polimorfismo en JavaScript</h4>
      <p>Son los metodos que a pesar de ser heredados de una superclase <b>poseen diferentes algoritmos</b>, por lo que podria llamarse como el reemplazo de metodos.</p>
      <pre><code class="language-js">// Superclase
class Persona {
  caminar() {
    console.log('Soy una persona y estoy caminando');
  }
}
// Subclases
class Trabajador extends Persona {
  caminar() { // Polimorfismo
    console.log('Soy un trabajador y estoy caminando');
  }
}
class Estudiante extends Persona {
  caminar() { // Polimorfismo
    console.log('Soy un estudiante y estoy caminando');
  }
}

let objeto1 = new Persona();
let objeto2 = new Trabajador();
let objeto3 = new Estudiante();
objeto1.caminar();
objeto2.caminar();
objeto3.caminar();</code></pre>
    </section>
  </section>
</section>
<section>
  <h2 id="json">JSON</h2>
  <p><b>J</b>ava<b>S</b>cript <b>O</b>bject <b>N</b>otation (<b>JSON</b>) es un formato de archivo que permite almacenar datos en notacion de <b>Objetos de JavaScript</b>. Esto facilitando la lectura, la escritura y el manejo en general del archivo</p>
  <pre><code class="language-js">{
  "name" : "RukkaPlus",
  "age" : 15,
  "height" : 1.70,
  "languages" : ["HTML", "CSS", "JavaScript"]
}</code></pre>
  <p>Es muy parecido a un objeto de JavaScript</p>
  <section>
    <h3 id="json-0">Convirtiendo JSON en Objetos</h3>
    <p>Con esto viene un String, el texto sacado del archivo JSON. Por lo que podemos convertirlo en objetos adaptables al lenguaje <b>JavaScript</b></p>
    <pre><code class="language-js">// Convirtiendo un String JSON a Object
let objVar = JSON.parse('{"name":"John", "age":30, "city":"New York"}');
objVar["name"];
objVar["age"];
objVar["city"];</code></pre>
  </section>
  <section>
    <h3 id="json-1">Convirtiendo Objetos en JSON</h3>
    <p>Al igual que podemos hacer lo contrario, podemos convertir un Objeto de <b>JavaScript</b> en un String adaptable a JSON</p>
    <pre><code class="language-js">// Convirtiendo un Object a String JSON
let jsonFile = JSON.stringify(objVar);
console.log(jsonFile);</code></pre>
  </section>
  <section>
    <h3 id="json-2">Principales reglas de un archivo JSON</h3>
    <ol>
      <li>Siempre se actua como con un Objeto de <b>JavaScript</b> (siempre se usa la sintaxis <code>{"nombre de llave" : "valor"}</code>)</li>
      <li>Solo se permiten valores de tipo <code>Number</code>, <code>String</code>, <code>Array</code>, <code>Object</code>, <code>Boolean</code> y <code>null</code>. Esta prohibido otros tipos de datos (incluyendo <code>Function</code>, <code>Date</code> y <code>undefined</code>)</li>
      <li>Se mantiene la sintaxis original de agrupacion de datos (los <code>[]</code> representan Arrays y los <code>{}</code> representan Objetos)</li>
    </ol>
  </section>
</section>
{% endblock %}